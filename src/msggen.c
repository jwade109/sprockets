#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <assert.h>

#include <dynamic_array.h>

typedef enum
{
    U8 = 0,
    U16,
    U32,
    S8,
    S16,
    S32,
    F32,
    STR,
    NUM_FIELD_TYPES
}
field_type;

const char *c_field_strings[NUM_FIELD_TYPES] = {
    "uint8_t",
    "uint16_t",
    "uint32_t",
    "int8_t",
    "int16_t",
    "int32_t",
    "float",
    "char"
};

const char *msg_field_strings[NUM_FIELD_TYPES] = {
    "u8",
    "u16",
    "u32",
    "s8",
    "s16",
    "s32",
    "f32",
    "str"
};

const char *field_printf_specifiers[NUM_FIELD_TYPES] = {
    "d",
    "d",
    "d",
    "d",
    "d",
    "d",
    "lf",
    "s"
};

int stoft(const char *str)
{
    int ret = -1;
    for (size_t i = 0; i < NUM_FIELD_TYPES; ++i)
    {
        const char *ts = msg_field_strings[i];
        if (strcmp(ts, str) == 0)
        {
            ret = i;
            break;
        }
    }
    return ret;
}

typedef struct
{
    field_type type;
    char name[100];
}
message_field_t;

void get_filename(const char *path, size_t *start, size_t *end)
{
    size_t len = strlen(path);
    *start = 0;
    *end = len;
    for (size_t i = 0; i < len; ++i)
    {
        if (path[i] == '/')
        {
            *start = i + 1;
        }
        if (path[i] == '.' && i > 0)
        {
            *end = i;
        }
    }
}

void emit_autogen_header(FILE *out, const char *source_msg_file,
    const dynamic_array *fields)
{
    fprintf(out, "// autogenerated by msggen.c " \
        "from %s\n\n// message definition:\n", source_msg_file);

    for (size_t i = 0; i < fields->size; ++i)
    {
        message_field_t *field = array_get(fields, i);

        int type = field->type;
        const char *name = field->name;

        fprintf(out, "// %s %s\n", msg_field_strings[type], name);
    }
    fprintf(out, "\n");
}

void emit_include_directive(FILE *out, const char *header_include)
{
    fprintf(out, "#include <%s>\n", header_include);
}

void emit_header(FILE *out, const char *source_msg_file,
    const char *message_type_name,
    const dynamic_array *fields)
{
    emit_autogen_header(out, source_msg_file, fields);

    fprintf(out, "#ifndef SPROCKETS_AUTOGEN_MESSAGE_%s_H\n"
                 "#define SPROCKETS_AUTOGEN_MESSAGE_%s_H\n\n",
        message_type_name, message_type_name);

    emit_include_directive(out, "stdint.h");
    emit_include_directive(out, "stddef.h");

    fprintf(out, "\n#pragma pack(push, 1)\ntypedef struct\n{\n");

    for (size_t i = 0; i < fields->size; ++i)
    {
        message_field_t *field = array_get(fields, i);

        int type = field->type;
        const char *name = field->name;

        if (type == STR)
        {
            fprintf(out, "    char %s[128];\n", name);
        }
        else
        {
            fprintf(out, "    %s %s;\n", c_field_strings[type], name);
        }
    }

    fprintf(out, "}\n%s_t;\n#pragma pack(pop)\n", message_type_name);

    fprintf(out, "\nvoid print_%s(const %s_t *m);\n",
        message_type_name, message_type_name);
    fprintf(out, "\nvoid serialize_%s(const %s_t *m, uint8_t *dst);\n",
        message_type_name, message_type_name);
    fprintf(out, "\nint deserialize_%s(%s_t *dst, const uint8_t *buffer, size_t len);\n\n",
        message_type_name, message_type_name);

    fprintf(out, "#endif // SPROCKETS_AUTOGEN_MESSAGE_%s_H\n\n", message_type_name);
}

void emit_source(FILE *out, const char *source_msg_file,
    const char *message_type_name,
    const dynamic_array *fields)
{
    emit_autogen_header(out, source_msg_file, fields);

    char buffer[100];
    sprintf(buffer, "msg/%s.h", message_type_name);
    emit_include_directive(out, buffer);
    emit_include_directive(out, "stdio.h");
    emit_include_directive(out, "string.h");

    fprintf(out, "\nvoid print_%s(const %s_t *m)\n{\n",
        message_type_name, message_type_name);
    fprintf(out, "    printf(\"%s_t \");\n", message_type_name);

    for (size_t i = 0; i < fields->size; ++i)
    {
        message_field_t *field = array_get(fields, i);
        if (field->type == F32)
        {
            fprintf(out, "    printf(\"%s=%%%s \", (double) m->%s);\n",
                field->name,
                field_printf_specifiers[field->type],
                field->name);
        }
        else
        {
            fprintf(out, "    printf(\"%s=%%%s \", m->%s);\n",
                field->name,
                field_printf_specifiers[field->type],
                field->name);
        }
    }

    fprintf(out, "    printf(\"\\n\");\n}\n");

    fprintf(out, "\nvoid serialize_%s(const %s_t *m, uint8_t *dst)\n{\n",
        message_type_name, message_type_name);
    fprintf(out, "    memcpy(dst, m, sizeof(%s_t));\n", message_type_name);
    fprintf(out, "}\n");

    fprintf(out, "\nint deserialize_%s(%s_t *dst, const uint8_t *buffer, size_t len)\n{\n",
        message_type_name, message_type_name);
    fprintf(out, "    if (len != sizeof(%s_t)) { return -1; }\n", message_type_name);
    fprintf(out, "    memcpy(dst, buffer, len);\n");
    fprintf(out, "    return 0;\n");
    fprintf(out, "}\n\n");

}

int main(int argc, char **argv)
{
    if (argc < 5)
    {
        printf("usage: %s [in.msg] [out.h] [out.c] [name]\n", argv[0]);
        return 1;
    }


    dynamic_array fields;

    init_array(&fields, sizeof(message_field_t), 200);

    const char *infile = argv[1];
    const char *out_header = argv[2];
    const char *out_source = argv[3];
    const char *message_type_name = argv[4];

    printf("Message definition: %s\n", infile);
    printf("Header: %s\n", out_header);
    printf("Source: %s\n", out_source);
    printf("Message name: %s\n", message_type_name);

    FILE *in = fopen(infile, "r");

    if (!in)
    {
        printf("Failed to load %s.\n", infile);
        return 1;
    }

    ssize_t read;
    char *line = 0;
    size_t len = 0;
    while ((read = getline(&line, &len, in)) != -1)
    {
        char type[100];
        char name[100];

        if (sscanf(line, "%s %s", type, name) == 2)
        {
            message_field_t *field = array_new(&fields);
            strcpy(field->name, name);
            field->type = stoft(type);

            if (field->type < 0)
            {
                printf("Bad line: %s\n", line);
                return 1;
            }
        }
        else
        {
            printf("Bad line: %s\n", line);
            return 1;
        }
    }

    if (line)
    {
        free(line);
    }

    FILE *out_h = fopen(out_header, "w");
    if (!out_h)
    {
        printf("Failed to open %s.\n", out_header);
        return 1;
    }
    FILE *out_c = fopen(out_source, "w");
    if (!out_c)
    {
        printf("Failed to open %s.\n", out_source);
        return 1;
    }

    emit_header(out_h, infile, message_type_name, &fields);
    emit_source(out_c, infile, message_type_name, &fields);

    fclose(in);
    fclose(out_h);
    fclose(out_c);

    free_array(&fields);

    printf("Done.\n");
    return 0;
}