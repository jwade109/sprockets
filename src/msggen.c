#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum
{
    U8 = 0,
    U16,
    U32,
    S8,
    S16,
    S32,
    F32,
    STR
}
field_type;

const char *c_field_strings[7] = {
    "uint8_t",
    "uint16_t",
    "uint32_t",
    "int8_t",
    "int16_t",
    "int32_t",
    "float"
};

const char *msg_field_strings[7] = {
    "u8",
    "u16",
    "u32",
    "s8",
    "s16",
    "s32",
    "f32"
};

int stoft(const char *str)
{
    int ret = -1;
    for (size_t i = 0; i < 7; ++i)
    {
        const char *ts = msg_field_strings[i];
        if (strcmp(ts, str) == 0)
        {
            ret = i;
            break;
        }
    }
    return ret;
}

typedef struct
{
    field_type type;
    char name[100];
}
message_field_t;

int main(int argc, char **argv)
{
    if (argc < 3)
    {
        printf("usage: %s [in.msg] [out.h]\n", argv[0]);
        return 1;
    }

    const size_t max_fields = 200;
    message_field_t fields[max_fields];
    for (size_t i = 0; i < max_fields; ++i)
    {
        fields[i].type = U8;
        memset(fields[i].name, 0, sizeof(fields[i].name));
    }

    const char *infile = argv[1];
    const char *outfile = argv[2];

    FILE *in = fopen(infile, "r");
    FILE *out = fopen(outfile, "w");
    if (!in)
    {
        printf("Failed to load %s.\n", infile);
        return 1;
    }
    if (!out)
    {
        printf("Failed to open %s.\n", outfile);
        return 1;
    }

    fprintf(out, "// autogenerated by msggen.c " \
        "from %s\n\n// message definition:\n\n", infile);

    ssize_t read;
    char *line = 0;
    size_t len = 0;
    size_t field_idx = 0;
    while ((read = getline(&line, &len, in)) != -1)
    {
        char type[100];
        char name[100];

        fprintf(out, "// %s", line);

        if (sscanf(line, "%s %s", type, name) == 2)
        {
            strcpy(fields[field_idx].name, name);
            fields[field_idx].type = stoft(type);
            if (fields[field_idx].type < 0)
            {
                printf("Bad line: %s\n", line);
                return 1;
            }
            ++field_idx;
        }
        else
        {
            printf("Bad line: %s\n", line);
            return 1;
        }
    }

    fprintf(out, "\ntypedef struct\n{\n");

    for (size_t i = 0; i < field_idx; ++i)
    {
        int type = fields[i].type;
        const char *name = fields[i].name;

        printf("%zu: %s %s\n", i, msg_field_strings[type], name);
        fprintf(out, "    %s %s;\n", c_field_strings[type], name);
    }

    fprintf(out, "}\npacket_t;\n");

    fclose(in);
    fclose(out);

    if (line)
    {
        free(line);
    }

    printf("Done.\n");
    return 0;
}