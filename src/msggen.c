#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <assert.h>

#include <dynamic_array.h>

typedef enum
{
    U8 = 0,
    U16,
    U32,
    S8,
    S16,
    S32,
    F32,
    STR
}
field_type;

const char *c_field_strings[7] = {
    "uint8_t",
    "uint16_t",
    "uint32_t",
    "int8_t",
    "int16_t",
    "int32_t",
    "float"
};

const char *msg_field_strings[7] = {
    "u8",
    "u16",
    "u32",
    "s8",
    "s16",
    "s32",
    "f32"
};

const char *field_printf_specifiers[7] = {
    "d",
    "d",
    "d",
    "d",
    "d",
    "d",
    "d"
};

int stoft(const char *str)
{
    int ret = -1;
    for (size_t i = 0; i < 7; ++i)
    {
        const char *ts = msg_field_strings[i];
        if (strcmp(ts, str) == 0)
        {
            ret = i;
            break;
        }
    }
    return ret;
}

typedef struct
{
    field_type type;
    char name[100];
}
message_field_t;

void get_filename(const char *path, size_t *start, size_t *end)
{
    size_t len = strlen(path);
    *start = 0;
    *end = len;
    for (size_t i = 0; i < len; ++i)
    {
        if (path[i] == '/')
        {
            *start = i + 1;
        }
        if (path[i] == '.' && i > 0)
        {
            *end = i;
        }
    }
}

void emit_autogen_header(FILE *out, const char *source_msg_file,
    const dynamic_array *fields)
{
    fprintf(out, "// autogenerated by msggen.c " \
        "from %s\n\n// message definition:\n", source_msg_file);

    for (size_t i = 0; i < fields->size; ++i)
    {
        message_field_t *field = array_get(fields, i);

        int type = field->type;
        const char *name = field->name;

        fprintf(out, "// %s %s\n", msg_field_strings[type], name);
    }
    fprintf(out, "\n");
}

void emit_include_directive(FILE *out, const char *header_include)
{
    fprintf(out, "#include <%s>\n", header_include);
}

void emit_header(FILE *out, const char *source_msg_file,
    const char *message_type_name,
    const dynamic_array *fields)
{
    emit_autogen_header(out, source_msg_file, fields);

    fprintf(out, "#ifndef SPROCKETS_AUTOGEN_MESSAGE_%s_H\n"
                 "#define SPROCKETS_AUTOGEN_MESSAGE_%s_H\n\n",
        message_type_name, message_type_name);

    emit_include_directive(out, "stdint.h");

    fprintf(out, "\ntypedef struct\n{\n");

    for (size_t i = 0; i < fields->size; ++i)
    {
        message_field_t *field = array_get(fields, i);

        int type = field->type;
        const char *name = field->name;

        fprintf(out, "    %s %s;\n", c_field_strings[type], name);
    }

    fprintf(out, "}\n%s_t;\n", message_type_name);
    fprintf(out, "\nvoid print_%s(const %s_t *m);\n\n",
        message_type_name, message_type_name);

    fprintf(out, "#endif // SPROCKETS_AUTOGEN_MESSAGE_%s_H\n", message_type_name);
}

void emit_source(FILE *out, const char *source_msg_file,
    const char *message_type_name,
    const char *out_header_filename,
    const dynamic_array *fields)
{
    emit_autogen_header(out, source_msg_file, fields);

    emit_include_directive(out, out_header_filename);
    emit_include_directive(out, "stdio.h");

    fprintf(out, "\nvoid print_%s(const %s_t *m)\n{\n",
        message_type_name, message_type_name);
    fprintf(out, "    printf(\"%s_t\");\n", message_type_name);

    for (size_t i = 0; i < fields->size; ++i)
    {
        message_field_t *field = array_get(fields, i);
        fprintf(out, "    printf(\"%s=%%%s\", m->%s);\n",
            field->name,
            field_printf_specifiers[field->type],
            field->name);
    }

    fprintf(out, "    printf(\"\\n\");\n}\n");
}

int main(int argc, char **argv)
{
    if (argc < 4)
    {
        printf("usage: %s [in.msg] [out.h] [out.c]\n", argv[0]);
        return 1;
    }


    dynamic_array fields;

    init_array(&fields, sizeof(message_field_t), 200);

    char *infile = argv[1];
    const char *out_header = argv[2];
    const char *out_source = argv[3];

    FILE *in = fopen(infile, "r");

    char message_type_name[100];
    size_t fn_start, fn_end;
    get_filename(infile, &fn_start, &fn_end);
    assert(fn_end - fn_start < sizeof(message_type_name));
    memcpy(message_type_name, infile + fn_start, fn_end - fn_start);
    message_type_name[fn_end - fn_start + 1] = 0;

    printf("Message name: %s\n", message_type_name);

    if (!in)
    {
        printf("Failed to load %s.\n", infile);
        return 1;
    }

    ssize_t read;
    char *line = 0;
    size_t len = 0;
    while ((read = getline(&line, &len, in)) != -1)
    {
        char type[100];
        char name[100];

        if (sscanf(line, "%s %s", type, name) == 2)
        {
            message_field_t *field = array_new(&fields);
            strcpy(field->name, name);
            field->type = stoft(type);

            if (field->type < 0)
            {
                printf("Bad line: %s\n", line);
                return 1;
            }
        }
        else
        {
            printf("Bad line: %s\n", line);
            return 1;
        }
    }

    if (line)
    {
        free(line);
    }

    FILE *out_h = fopen(out_header, "w");
    if (!out_h)
    {
        printf("Failed to open %s.\n", out_header);
        return 1;
    }
    FILE *out_c = fopen(out_source, "w");
    if (!out_c)
    {
        printf("Failed to open %s.\n", out_source);
        return 1;
    }

    emit_header(out_h, infile, message_type_name, &fields);
    emit_source(out_c, infile, message_type_name, out_header, &fields);

    fclose(in);
    fclose(out_h);
    fclose(out_c);

    free_array(&fields);

    printf("Done.\n");
    return 0;
}